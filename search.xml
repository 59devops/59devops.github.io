<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[修改mysql时区的三种方法]]></title>
    <url>%2F2019%2F09%2F27%2F%E4%BF%AE%E6%94%B9mysql%E6%97%B6%E5%8C%BA%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法一：通过mysql命令行模式下动态修改1.1 查看mysql当前时间，当前时区1234567891011121314&gt; select curtime(); #或select now()也可以+-----------+| curtime() |+-----------+| 15:18:10 |+-----------+&gt; show variables like "%time_zone%";+------------------+--------+| Variable_name | Value |+------------------+--------+| system_time_zone | CST || time_zone | SYSTEM |+------------------+--------+2 rows in set (0.00 sec) time_zone说明mysql使用system的时区，system_time_zone说明system使用CST时区 1.2 修改时区123&gt; set global time_zone = &apos;+8:00&apos;; ##修改mysql全局时区为北京时间，即我们所在的东8区&gt; set time_zone = &apos;+8:00&apos;; ##修改当前会话时区&gt; flush privileges; #立即生效 方法二：通过修改my.cnf配置文件来修改时区123# vim /etc/my.cnf ##在[mysqld]区域中加上default-time_zone = &apos;+8:00&apos;# /etc/init.d/mysqld restart ##重启mysql使新时区生效 方法三：如果不方便重启mysql，又想临时解决时区问题，可以通过php或其他语言在初始化mysql时初始化mysql时区这里，以php为例，在mysql_connect()下使用: 1mysql_query(&quot;SET time_zone = &apos;+8:00&apos;&quot;) 这样可以在保证你不重启的情况下改变时区。但是mysql的某些系统函数还是不能用如：now()。这句，还是不能理解。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决zabbix设置为中文后图形中中文乱码的问题]]></title>
    <url>%2F2019%2F09%2F27%2F%E8%A7%A3%E5%86%B3zabbix%E8%AE%BE%E7%BD%AE%E4%B8%BA%E4%B8%AD%E6%96%87%E5%90%8E%E5%9B%BE%E5%BD%A2%E4%B8%AD%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、下载汉化的字体zabbix3.4中，存放字体的目录在/usr/share/zabbix/fonts/ 1wget -O /usr/share/zabbix/fonts/msyh.ttf https://raw.githubusercontent.com/chenqing/ng-mini/master/font/msyh.ttf 2、修改配置文件修改/usr/share/zabbix/include/defines.inc.php文件： 1vim /usr/share/zabbix/include/defines.inc.php 3、重启zabbix-server1systemctl restart zabbix-server.service]]></content>
      <categories>
        <category>zabbix</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS将U盘格式化为ext2/3/4格式]]></title>
    <url>%2F2019%2F09%2F27%2FMac-OS%E5%B0%86U%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%BAext2-3-4%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1、安装HomeBrew1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 2、安装e2fsprogs插件1brew install e2fsprogs 3、找到U盘盘符1diskutil list 4、取消U盘挂载1diskutil unmountdisk /dev/disk2 5、格式化为ext4格式1sudo $(brew --prefix e2fsprogs)/sbin/mkfs.ext4 /dev/disk2 回车，输入 Mac 密码再回车，过程需要稍等片刻，等待完成即可拔掉 U盘，这时候 U盘格式已经为 ext4 了。]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7安装Google Authenticator进行登陆二次验证]]></title>
    <url>%2F2019%2F09%2F27%2FCentOS-7%E5%AE%89%E8%A3%85Google-Authenticator%E8%BF%9B%E8%A1%8C%E7%99%BB%E9%99%86%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[1、安装依赖1yum install -y epel-* mercurial autoconf automake libtool pam-devel 2、安装google-authenticator1yum install -y google-authenticator 4、PAM组件配置google-authenticator1234vim /etc/pam.d/sshdauth required pam_google_authenticator.so# 或者echo "auth required pam_google_authenticator.so" &gt;&gt;/etc/pam.d/sshd 5、修改SSH配置1234567vim /etc/ssh/sshd_config# 将ChallengeResponseAuthentication no# 改为ChallengeResponseAuthentication yes# 或者sed -i 's/ChallengeResponseAuthentication no/ChallengeResponseAuthentication yes/g' /etc/ssh/sshd_config 6、重启SSH服务1systemctl restart sshd.service 7、生成google-authenticator配置12345678910111213141516171819202122232425262728293031323334353637383940414243google-authenticatorDo you want authentication tokens to be time-based (y/n) yWarning: pasting the following URL into your browser exposes the OTP secret to Google: https://www.google.com/chart?chs=200x200&amp;chld=M|0&amp;cht=qr&amp;chl=otpauth://totp/root@demo%3Fsecret%3DXQ2WB526GLPJ7SI64Z3RZISOEE%26issuer%3Ddemo 这里会有一个二维码，需要在手机上下载`googleauthenticator`APP扫码绑定 安卓 IOS手机都可以在应用商店搜索安装 Your new secret key is: XQ2WB526GLPJ7SI64Z3RZISOEEYour verification code is 917990Your emergency scratch codes are: 42623319 72314571 14476695 95764389 38976136Do you want me to update your "/root/.google_authenticator" file? (y/n) yDo you want to disallow multiple uses of the same authenticationtoken? This restricts you to one login about every 30s, but it increasesyour chances to notice or even prevent man-in-the-middle attacks (y/n) yBy default, a new token is generated every 30 seconds by the mobile app.In order to compensate for possible time-skew between the client and the server,we allow an extra token before and after the current time. This allows for atime skew of up to 30 seconds between authentication server and client. If youexperience problems with poor time synchronization, you can increase the windowfrom its default size of 3 permitted codes (one previous code, the currentcode, the next code) to 17 permitted codes (the 8 previous codes, the currentcode, and the 8 next codes). This will permit for a time skew of up to 4 minutesbetween client and server.Do you want to do so? (y/n) yIf the computer that you are logging into isn't hardened against brute-forcelogin attempts, you can enable rate-limiting for the authentication module.By default, this limits attackers to no more than 3 login attempts every 30s.Do you want to enable rate-limiting? (y/n) y 8、调整XShell登陆配置XShell登陆需要更改为Keyboard Interactive验证登陆。 9、登陆时需要结合手机APP上的验证码才可以登陆登陆的时候选择Keyboard Interactive验证登陆。 然后输入服务器密码 输入手机APP上的验证码 登陆成功 因为手机上的 google authenticator这个APP是根据时间来生成随机验证码的，所以必须保证服务器上的时间和手机时间一致，不然可能会出现无法登陆的情况！ 建议安装时间同步服务器或者安装一个自动同步时间的软件(例如：chrony) 123yum install -y chronysystemctl enable chronydsystemctl start chronyd]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins自定义主题安装]]></title>
    <url>%2F2019%2F09%2F27%2FJenkins%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[首先必须先安装Simple Theme Plugin插件 在http://afonsof.com/jenkins-material-theme/网站中生成需要的主题css文件 将jenkins-material-theme.css文件上传到Jenkins服务器 创建目录，并将css文件放在对应的目录中。Jenkins默认的目录在/var/jenkins_home/ 12mkdir -p /var/jenkins_home/userContent/material/cp jenkins-material-theme.css /var/jenkins_home/userContent/material/ 在Jenkins中设置 保存之后会自动重新加载主题]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins+GitLab+Ansible-playbook的环境安装(yum)]]></title>
    <url>%2F2019%2F09%2F27%2FJenkins-GitLab-Ansible-playbook%E7%9A%84%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85-yum%2F</url>
    <content type="text"><![CDATA[1、安装GitLab1.1 配置gitlab的yum源123# 参考：https://packages.gitlab.com/gitlab/gitlab-ce/install#bash-rpmcurl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh|bashyum install -y gitlab-ce 1.2 启动GitLab与管理123456gitlab-ctl reconfiguregitlab-ctl startgitlab-ctl statusgitlab-ctl stopgitlab-ctl restartps -aux|grep runsvdir 2、安装JDK1yum install -y java-1.8.0-openjdk 3、安装Jenkins3.1 配置Jenkins的yum源12wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reporpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 3.2 安装Jenkins1yum install -y jenkins 3.3 启动jenkins123systemctl start jenkinssystemctl enable jenkinssystemctl status jenkins 3.4 修改Jenkins配置文件3.4.1 修改Jenkins运行用户1234vim /etc/sysconfig/jenkins# 修改$JENKINS_USER，并去掉当前行的注释$JENKINS_USER='work' 3.4.2 修改Jenkins相关文件夹用户权限123chown -R work:work /var/lib/jenkinschown -R work:work /var/cache/jenkinschown -R work:work /var/log/jenkins 3.4.3 重启Jenkins服务并检查运行Jenkins的用户是否已经切换为work12systemctl restart jenkinsps -ef|grep jenkins 3.5 Jenkins插件推荐123456781.Git Parameter # 构建参数2.build-name-setter # $&#123;BUILD_NUMBER&#125;-$moudle-$release_tag3.user build vars plugin # 获取运行job的用户名4.Jenkins修改本地默认主题 主题URL：http://afonsof.com/jenkins-material-theme/ 1) Jenkins安装 Simple Theme插件 2) 浏览器下载stylish css导入服务器。放到 /var/cache/jenkins/war/css 3) 然后在Jenkins的系统配置中添加Theme配置 http://10.0.0.100:8080/css/jenkins-material-theme.css]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker构建持续集成环境]]></title>
    <url>%2F2019%2F09%2F27%2FDocker%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1、CI/CD介绍CI/CD是一个持续的闭环的流程。 1.1 什么是CI？​ 在软件工程中，持续集成（CI）是指将所有开发者的工作副本每天多次合并到主干的做法。Grady Booch 在1991年的 Booch method 中首次命名并提出了 CI 的概念，尽管在当时他并不主张每天多次集成。而 XP（Extreme programming，极限编程）采用了 CI 的概念，并提倡每天不止一次集成。 1.2 什么是CD？​ 持续交付/持续部署(CD)就是在持续集成的基础上，产品不断的迭代更新，最终能够交付到客户手中或者部署到生成环境。 1.3 CI/CD的优点 解放了重复性劳动 自动化部署工作可以解放集成、测试、部署等重复性劳动，而机器集成的频率明显比手工高很多。 更快地修复问题 持续集成更早的获取变更，更早的进入测试，更早的发现问题，解决问题的成本显著下降。 更快的交付成果 更早发现错误减少解决错误所需的工作量。集成服务器在构建环节发现错误可以及时通知开发人员修复。集成服务器在部署环节发现错误可以回退到上一版本，服务器始终有一个可用的版本。 减少手工的错误 在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。 减少了等待时间 缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间可以出现的等待时机。持续集成，意味着开发、集成、测试、部署也得以持续。 更高的产品质量 集成服务器往往提供代码质量检测等功能，对不规范或有错误的地方会进行标致，也可以设置邮件和短信等进行警告。 1.4 CI/CD最佳实践 频繁检出代码 有时候代码冲突无可避免，频繁检出代码，可以让本地的副本和代码库中的版本最小差异化。 频繁提交代码 与频繁检出代码的原理类似，频繁提交代码，可以让其他人检出副本和代码库中的版本最小差异化。 减少分支，回归主干 多个分支并行应及早将变更集成到主干中，避免同时维护软件的多个版本。 使用自动化构建 可以使用Maven、Ant等来实现自动化构建，可以在构建过程中实现自动化测试。前提是有写单元测试用例。 提交测试 在提交工作之前，每个程序员必须本地集成所有代码，做一个完整的构建和运行，并通过所有的单元测试，这样能减少集成测试在集成服务器上构建失败的风险。 当前状态对每个人都可见 集成服务器在持续集成过程中发现问题应及时发送警告给相关的干系人。 2、发布流程设计 2.1 发布流程 开发将代码提交到Git服务器(GitLab/GitHub/SVN等) Jenkins拉取Git服务器上的代码通过Maven或者Ant构建 docker结合脚本(docker build &amp; docker run)将构建好的代码封装在docker镜像中并推送到Docker镜像仓库 不同的环境的配置文件可以通过配置中心来配置，测试环境拉取对应的镜像和配置文件到测试环境中运行 测试通过后，结合配置中心，拉取镜像和正式环境配置文件，在正式环境中运行 2.2 配置中心的必要性​ 配置中心能够根据不同的环境配置好不同的配置文件，免去了人工替换配置文件的步骤，减少了出错率，大大的提高持续集成、持续部署、持续交付的效率。目前常用的配置中心有apollo和disconf等。 ​ 配置中心的搭建可以在网上找到各种文档，也可以在参考官方的安装文档。apollo安装、disconf安装 3、部署Git服务器3.1 安装git1yum install -y git 3.2 添加git用户并设置密码12useradd gitpasswd git 3.3 创建项目1234567# 1.切换到git用户su - git# 2.创建项目mkdir -p solo.gitcd solo.git/# 3.初始化项目git --bare init 4.4 Jenkins服务器实现免密码交互1234# 1.生成私钥ssh-keygen# 2.将公钥发送到Git服务器ssh-copy-id git@10.0.0.20 4、部署Harbor镜像仓库4.1 部署方式 在线安装 离线安装 OVA程序安装 4.2 离线安装4.2.1 安装docker和docker-compose​ 因为Harbor离线安装方式是基于docker-compose编排安装的。 12345678# 1.获取docker-composesudo curl -L "https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose# 2.给予可执行权限sudo chmod +x /usr/local/bin/docker-compose# 3.加入环境变量，有多种方式，个人认为下面的方式最简单有效sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose# 4.检查docker-compose --version 4.2.2 下载Harbor离线安装包12# Harbor下载地址https://github.com/goharbor/harbor/releasescd /opt &amp;&amp; wget https://storage.googleapis.com/harbor-releases/release-1.8.0/harbor-offline-installer-v1.8.0.tgz 4.2.3 安装Harbor4.2.3.1 解压安装包12# 1.解压安装包tar xf harbor-offline-installer-v1.8.0.tar 4.2.3.2 修改配置文件1234567891011121314151617181920212223242526vim /opt/harbor/harbor.ymlhostname: harbor.biu2ful.xyzhttps: port: 443 certificate: /etc/docker/certs.d/harbor.biu2ful.xyz/ca.crt private_key: /etc/docker/certs.d/harbor.biu2ful.xyz/ca.keyharbor_admin_password: Harbor123456database: password: root123data_volume: /dataclair: updaters_interval: 12 http_proxy: https_proxy: no_proxy: 127.0.0.1,localhost,core,registryjobservice: max_job_workers: 10chart: absolute_url: disabledlog: level: info rotate_count: 50 rotate_size: 200M location: /var/log/harbor_version: 1.8.0 ​ 精简后的配置文件如下图： 4.2.3.3 生成对应的签名证书文件123456# 1.创建证书存放路径mkdir -p /etc/docker/certs.d/harbor.biu2ful.xyz/# 2.生成自签名证书key文件openssl genrsa -out /etc/docker/certs.d/harbor.biu2ful.xyz/ca.key 2048# 3.生成自签名证书crt文件openssl req -x509 -new -nodes -key /etc/docker/certs.d/harbor.biu2ful.xyz/ca.key -subj "/CN=harbor.biu2ful.xyz" -days 100000 -out /etc/docker/certs.d/harbor.biu2ful.xyz/ca.crt 4.2.3.4 配置Harbor1cd /opt/harbor/ &amp;&amp; ./prepare 4.2.3.4 安装Harbor1./install 4.3 客户端配置4.3.1 创建证书存放路径1mkdir -p /etc/docker/certs.d/harbor.biu2ful.xyz/ 4.3.2 获取自签名证书crt文件12# 从Harbor所在服务器scp证书文件到docker客户端，其中10.0.0.30是docker客户端的地址，根据自己的对应修改。scp ca.crt root@10.0.0.30:/etc/docker/certs.d/harbor.biu2ful.xyz/ 4.3.3 重启docker服务1systemctl restart docker.service 4.4 测试是否能够正常使用4.4.1浏览器访问​ 访问：https://harbor.biu2ful.xyz/ 4.4.2 docker客户端登陆1docker login harbor.biu2ful.xyz 4.4.3 推送和拉取镜像123# 推送镜像到Harbor仓库docker tag mysql:5.6 harbor.biu2ful.xyz/library/mysql:5.6docker push harbor.biu2ful.xyz/library/mysql:5.6 123# 从Harbor仓库拉取镜像docker image rm harbor.biu2ful.xyz/library/mysql:5.6docker pull harbor.biu2ful.xyz/library/mysql:5.6 5、构建业务基础镜像5.1 编写Dockerfile12345678910FROM centos:7MAINTAINER staryjie@gmail.comRUN yum install unzip iproute -yENV JAVA_HOME /usr/local/jdk1.8.0_141/ADD apache-tomcat-8.0.46.tar.gz /usr/localRUN mv /usr/local/apache-tomcat-8.0.46.tar.gz /usr/local/tomcatWORKDIR /usr/local/tomcatEXPOSE 8080ENTRYPOINT [&quot;./bin/catalina.sh&quot;, &quot;run&quot;] 5.2 通过Dockerfile构建镜像1docker build -t tomcat:v1 . 5.3 将镜像推送到Harbor仓库12docker tag tomcat:v1 harbor.biu2ful.xyz/test/tomcat:vdocker push harbor.biu2ful.xyz/test/tomcat:v1 6、测试服务器安装Docker6.1 安装依赖1yum install -y yum-utils device-mapper-persistent-data lvm2 chrony 6.2 添加阿里云的docker仓库1yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 6.3 安装docker1yum install -y docker-ce docker-ce-cli containerd.io 6.4 启动并设置开机自启12systemctl start docker.servicesystemctl enable docker.service 6.5 配置daocloud加速1234systemctl start docker.servicesystemctl enable docker.servicesystemctl start chronyd.servicesystemctl enable chronyd.service 6.6 重启docker服务1systemctl restart docker 6.7 检查是否正常安装docker1docker run hello-world 下面是一个很简单的安装脚本： 1234567891011121314151617#!/bin/bash# 1.安装依赖yum install -y yum-utils device-mapper-persistent-data lvm2 chrony# 2.添加阿里云的docker仓库yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 3.安装dockeryum install -y docker-ce docker-ce-cli containerd.io# 4.启动并设置开机自启systemctl start docker.servicesystemctl enable docker.service# 5. 配置daocloud加速curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io# 6.重启docker服务systemctl restart docker# 7.检查是否正常安装dockerdocker run hello-world 7、Jenkins安装7.1 构建jenkins镜像​ 编写Dockerfile： 1234FROM jenkins/jenkinsUSER rootRUN mv /etc/apt/sources.list /etc/apt/sources.list.bak &amp;&amp; wget http://static.staryjie.com/sources.list -O /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y git libltdl-dev ​ 通过Dockerfile构建镜像： 1docker build -t jenkins:v1 . 在安装的时候发现版本太低的Jenkins很多插件都装不上，建议使用最新版本的Jenkins。 https://www.cnblogs.com/sxdcgaq8080/p/10489326.html 7.2 通过镜像启动容器123456789101112131415161718docker run -d \--name jenkins \-p 8080:8080 \-p 50000:50000 \# jenkins目录-v /var/jenkins_home/:/var/jenkins_home \# 挂载宿主机maven到jenkins容器-v /usr/local/maven3.6/:/usr/local/maven \# 挂载宿主机jdk到jenkins容器-v /usr/local/jdk1.8.0_141/:/usr/local/jdk \# 挂载宿主机docker到jenkins容器-v /var/run/docker.sock:/var/run/docker.sock \# 将docker相关命令挂载到jenkins容器-v $(which docker):/usr/bin/docker \# 挂载sshkey，实现免密码-v ~/.ssh:/root/.ssh \jenkins:v1# registry.cn-hangzhou.aliyuncs.com/harbor-aliyun/jenkins:v1 7.3 浏览器访问http://ip:8080 7.4 自定义安装Jenkins插件 7.5 创建管理员账号 8、Jenkins基本配置8.1 配置Jenkins的URL​ 根据自己的实际情况设置，可以直接是ip+端口，或者域名通过nginx或者其他web中间件代理。 8.2 开始使用Jenkins 开始使用Jenkins之后进到Jenkins的首页： 8.3 系统管理-全局配置8.3.1 配置JDK​ 在启动jenkins容器的时候我们将宿主机的jdk挂载到了容器中，所以不需要勾选自动安装，只需要将启动时候指定的路径填写好即可： 8.3.2 配置git​ git是通过yum安装的，所以配置直接使用默认的就可以： 8.3.3 配置Maven​ 和jdk配置一样，在启动jenkins容器的时候就已经将宿主机的Maven挂载在容器中了，所以只要配置好路径即可： 8.4 系统管理-系统配置8.4.1 SSH remote hosts配置​ 增加一个Jenkins要访问的docker主机的ip，为了实现免密码交互，将Jenkins主机的公钥发送到docker主机： 1ssh-copy-id root@10.0.0.30 ​ 在Jenkins中添加凭据： ​ 在系统配置中添加SSH remote hosts配置： 9、Jenkins创建项目9.1 创建项目​ 在首页有一个创建新任务的选项。 ​ 创建一个Maven的项目： 9.2 项目配置9.2.1 源码管理​ 在源码管理选项中选择自己的源码管理方式和源码拉取地址： 9.2.2 Maven构建前-配置Maven跳过项目测试用例​ 参数是：clean package -Dmaven.test.skip=true 9.2.3 Maven构建后配置​ 通过构建后配置将war包基于基础业务镜像进行构建新的镜像，并上传到Harbor镜像仓库： 123456789101112131415cd $WORKSPACEdocker login -u admin -p Harbor123456 harbor.biu2ful.xyzcat &gt; Dockerfile &lt;&lt; EOFFROM harbor.biu2ful.xyz/test/tomcat:v1MAINTAINER staryjie@gmail.comCOPY target/solo.war /tmp/ROOT.warRUN rm -rf /usr/local/tomcat/webapps/* &amp;&amp; \ unzip /tmp/ROOT.war -d /usr/local/tomcat/webapps/ROOT &amp;&amp; \ rm -f /tmp/ROOT.warENTRYPOINT ["./bin/catalina.sh", "run"]EOFdocker build -t harbor.biu2ful.xyz/test/solo:v1 .docker push harbor.biu2ful.xyz/test/solo:v1 9.2.4 构建完成后在远程主机上执行命令​ 上一步将新构建的镜像推送到Harbor仓库，这一步通过仓库的镜像在远程主机上启动一个容器。 12345BUILD_ID=DONTKILLMEdocker login -uadmin -pHarbor123456 harbor.biu2ful.xyzdocker rm -f solo|truedocker image rm -f harbor.biu2ful.xyz/test/solo:v1|truedocker run -d --name solo -p 8888:8080 -v /usr/local/jdk1.8.0_141/:/usr/local/jdk1.8.0_141/ harbor.biu2ful.xyz/test/solo:v1 10、测试10.1 将项目代码推送到Git服务器​ 这里通过一个GitHub上java的开源博客系统来测试。 123456789101112# 1.将Git服务器新建的仓库clone到本地cd /root/cicd &amp;&amp; git clone root@10.0.0.20:/home/git/solo.git# 2.获取代码git clone https://github.com/b3log/solo.git# 3.将GitHub上clone的代码复制到从Git仓库clone的空仓库里面cp ./solo-master/* ./solo/ -rf# 4.将代码通过git提交到Git服务器创建好的仓库git config --global user.email "staryjie@163.com"git config --global user.name "staryjie"git add .git commit -m "all"git push origin master 10.2 Jenkins构建10.2.1 构建项目​ 通过上面已经创建的Maven项目solo_blog来构建： 10.2.3 查看控制台输出​ 点击立即构建之后就可以点击查看控制台输出来查看整个构建过程: ​ 第一次构建需要花费的时间比较多，耐心等待一会儿就可以看到构建结果： ​ 在服务器上查看构建好的war包： ​ 添加构建后将war包和基础镜像构建新镜像并推送到Harbor仓库的配置后，再次构建： ​ 在Harbor仓库查看镜像： ​ 配置了远程主机拉取镜像并运行容器之后，查看Jenkins执行结果： ​ 在远程主机查看是否有对应的镜像和已经运行的叫solo的容器： ​ 在浏览器上访问：http://10.0.0.30:8888]]></content>
      <categories>
        <category>CI&amp;CD</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>CI&amp;CD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过阿里云Python SDK管理ECS安全组]]></title>
    <url>%2F2019%2F09%2F27%2F%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91Python-SDK%E7%AE%A1%E7%90%86ECS%E5%AE%89%E5%85%A8%E7%BB%84%2F</url>
    <content type="text"><![CDATA[准备工作1231.服务器操作系统 CentOS72.Python版本 2.7.53.阿里云账号、Access Key ID、Access Key Secret、安全组ID、Region ID(如cn-shanghai) 1、安装pip12345# 默认没有安装pip，首先先安装pipcurl https://bootstrap.pypa.io/get-pip.py -o get-pip.pypython get-pip.py# 检查是否安装完成pip -V 2、安装阿里云Python SDK1pip install aliyun-python-sdk-ecs 3、Python SDK实现安全组的增加和删除3.1 增加安全组规则12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/local/bin/python2# -*- coding:utf-8 -*-from aliyunsdkcore.client import AcsClientfrom aliyunsdkecs.request.v20140526 import AuthorizeSecurityGroupRequestimport sysclass AliGroup: def __init__(self, AccessKey, AccessSecret, RegionId): self.AccessKey = AccessKey self.AccessSecret = AccessSecret self.RegionId = RegionId def client(self): """用于创建AcsClient实例 """ client = AcsClient(self.AccessKey, self.AccessSecret, self.RegionId) return client def authorizeSecurityGroupRequest(self, PortRange, SourceCidrIp, Priority=1, IpProtocol='tcp', SecurityGroupId='sg-bp1be0nm1c8es3sonuyy'): """用于添加安全组规则 """ # 创建AuthorizeSecurityGroupRequest实例 request = AuthorizeSecurityGroupRequest.AuthorizeSecurityGroupRequest() # 设置安全组ID request.set_SecurityGroupId(SecurityGroupId) # 设置协议，比如TCP或者UDP request.set_IpProtocol(IpProtocol) # 设置端口范围 request.set_PortRange(PortRange) # 如果存在源ip，则设置源ip if SourceCidrIp: request.set_SourceCidrIp(SourceCidrIp) # 设置优先级 request.set_Priority(Priority) # 设置规则的动作为接受 request.set_Policy('accept') # 设置接收数据格式为json request.set_accept_format('json') return requestif __name__ == '__main__': # AliGroup类实例化 ali = AliGroup("LTAIgURtYA5lRIdF", "Bz4X2kHtW9EbLP3uAU4Bx7kT1xUUbn", "cn-hangzhou") # 创建AcsClient实例 clt = ali.client() # 添加安全组规则，由于优先级、协议和安全组ID已经设置默认参数，所以只需要在运行脚本时输入端口范围和源ip两个参数 add = ali.authorizeSecurityGroupRequest(sys.argv[1], sys.argv[2]) # 打印输出 res = clt.do_action_with_exception(add) print res 3.2 删除安全组规则1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/local/bin/python2# -*- coding:utf-8 -*-from aliyunsdkcore.client import AcsClientfrom aliyunsdkecs.request.v20140526 import RevokeSecurityGroupRequestimport sysclass AliGroup: def __init__(self, AccessKey, AccessSecret, RegionId): self.AccessKey = AccessKey self.AccessSecret = AccessSecret self.RegionId = RegionId def client(self): """用于创建AcsClient的实例 """ client = AcsClient(self.AccessKey, self.AccessSecret, self.RegionId) return client def revokeSecurityGroupRequest(self, PortRange, SourceCidrIp, Priority=1, IpProtocol='tcp', SecurityGroupId='sg-bp1be0nm1c8es3sonuyy'): """删除安全组规则 """ request = RevokeSecurityGroupRequest.RevokeSecurityGroupRequest() request.set_SecurityGroupId(SecurityGroupId) request.set_IpProtocol(IpProtocol) request.set_PortRange(PortRange) if SourceCidrIp: request.set_SourceCidrIp(SourceCidrIp) request.set_Policy('accept') request.set_accept_format('json') return requestif __name__ == '__main__': ali = AliGroup("LTAIgURtYA5lRIdF", "Bz4X2kHtW9EbLP3uAU4Bx7kT1xUUbn", "cn-hangzhou") clt = ali.client() rem = ali.revokeSecurityGroupRequest(sys.argv[1], sys.argv[2]) res = clt.do_action_with_exception(rem) print res 4、测试4.1 测试新增安全组规则 执行脚本添加规则 web控制台查看安全组 4.2 测试删除安全组规则 执行脚本删除规则 web控制台查看安全组 很明显，之前添加的规则已经被删除了。]]></content>
      <categories>
        <category>aliyun</category>
      </categories>
      <tags>
        <tag>aliyun</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyecharts报错'pyecharts' has no attribute 'Bar'的解决办法]]></title>
    <url>%2F2019%2F09%2F27%2Fpyecharts%E6%8A%A5%E9%94%99-pyecharts-has-no-attribute-Bar-%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、出错原因因为用下面语句安装pyecharts时，默认会安装最新版本的pyecharts，python解释器版本更新的速度慢很多，现在的python解释器默认的是与0.1.9.4版本的pyecharts配合，你安装最新的，python解释器不能识别，所以会报错。 1pip install pyecharts 2、解决方法1234# 1.先安装wheelpip install wheel# 2.再安装pyecharts0.1.9.4版本pip install pyecharts==0.1.9.4 3、验证123456from pyecharts import Barbar1 = Bar("我的第一个图表", "副标题")bar1.add("服装", ['衬衣', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子'], [5, 20, 36, 10, 75, 90])bar1.show_config()bar1.render() 运行上面的代码会生成如下的render.html文件： 在浏览器打开：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pyecharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pipenv简单使用]]></title>
    <url>%2F2019%2F09%2F27%2Fpipenv%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[pipenv 是 Pipfile 主要倡导者、requests 作者 Kenneth Reitz 写的一个命令行工具，主要包含了Pipfile、pip、click、requests和virtualenv。Pipfile和pipenv本来都是Kenneth Reitz的个人项目，后来贡献给了pypa组织。Pipfile是社区拟定的依赖管理文件，用于替代过于简陋的 requirements.txt 文件。 1、安装pipenv 参考：https://github.com/pypa/pipenv 1.1 pip安装1pip install pipenv 1.2 Mac通过brew安装1brew install pipenv 2、pipenv简单使用2.1 创建虚拟环境1234# 进入项目目录cd projectdir# 创建虚拟环境pipenv install 上面的命令会自动在~/.local/share/virtualenvs/目录下创建一个projectdir加一串随机字符串的虚拟环境目录。 2.2 创建指定python版本的虚拟环境1234# 指定python版本为3.6.5pipenv install --python 3.6.5# 或者pipenv --python 3.6.5 2.3 修改pipenv默认虚拟环境位置为当前目录下12# 设置环境变量PIPENV_VENV_IN_PROJECT=1export export PIPENV_VENV_IN_PROJECT=1 在初始化虚拟环境的时候，pipenv默认会把虚拟环境的python目录以 及后来安装的各种模块放到/home/$username/.local/share/virtualenvs里，一般/和home是在一个分区的(之前就遇到过/所在的分区写满了，整个服务器都挂掉了)，如果想放到其他地方可以有以下几种方法： export PIPENV_VENV_IN_PROJECT=1 设置这个环境变量，pipenv会在当前目录下创建.venv的目录，以后都会把模块装到这个.venv下。 自己在项目目录下手动创建.venv的目录，然后运行 pipenv run 或者 pipenv shell pipenv都会在.venv下创建虚拟环境。 设置WORKON_HOME到其他的地方 （如果当前目录下已经有.venv,此项设置失效）。 2.4 激活虚拟环境1pipenv shell 2.5 安装相关模块并加入到Pipfile123pipenv install packagename# 比如pipenv install flask 2.6 安装固定版本模块并加入到Pipfile1pipenv install django==1.11 2.7 显示虚拟环境信息1pipenv --venv 2.8 显示目录信息1pipenv --where 2.9 显示Python解释器信息1pipenv --py 2.10 查看目前安装的库及其依赖1pipenv graph 2.11 检查安全漏洞1pipenv check 2.12 卸载全部包1pipenv uninstall --all 3、设置pipenv安装源为国内源修改当前目录下Pipfile文件，将[source]下的url属性改成国内的源即可： 1234[[source]]url = &quot;https://mirrors.aliyun.com/pypi/simple&quot;verify_ssl = truename = &quot;pypi&quot;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用GitHub从零开始搭建一个博客]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%88%A9%E7%94%A8GitHub%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一般我们要搭建一个个人的博客站点需要买服务器、域名，装各种运行环境等等，非常的费钱费力。 其实就算没有这些，我们也是照样可以通过Hexo框架结合GitHub Pages搭建一个自己的博客站点的。 Hexo 这个博客框架没有那么重量级，它是 MarkDown 直接写文章的，然后 Hexo 可以直接将文章编译成静态网页文件并发布，所以这样文章的内容、标题、标签等信息就没必要存数据库里面了，是直接纯静态页面了，这就解决了数据库的问题。 1、准备条件 GitHub账号 域名(可选) 2、新建GitHub项目首先在 GitHub 新建一个仓库（Repository），名称为 {username}.github.io，注意这个名比较特殊，必须要是 github.io 为后缀结尾的。比如我的用户名是59devops，那么就新建一个59devops.github.io的仓库。 3、为仓库配置SSH-Key因为后期我们更新文章或者提交代码需要有相应的权限才可以，通过用户名和密码不方便且不安全，所以非常有必要配置SSH-Key密钥。 3.1 创建密钥对12cd ~/. sshssh-keygen -t rsa -C "邮件地址" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 3.2 测试是否成功1ssh -T git@github.com 如上图显示，则表示SSH-Key配置成功！ 3.3 配置Git信息12git config --global user.name "59devops"git config --global user.email "59devops@gmail.com" 4、安装环境4.1 安装Node.js首先在自己的电脑上安装 Node.js，下载地址：https://nodejs.org/zh-cn/download/，可以安装 Stable 版本。 安装完毕之后，确保环境变量配置好，能正常使用 npm 命令。 1npm --version 4.2 安装HexoHexo是一个博客框架，Hexo 官方还提供了一个命令行工具，用于快速创建项目、页面、编译、部署 Hexo 博客，所以在这之前我们需要先安装 Hexo 的命令行工具。 1sudo npm install -g hexo-cli 安装完毕之后，确保环境变量配置好，能正常使用 hexo 命令。 1hexo --version 5、初始化项目5.1 创建项目使用 Hexo 的命令行创建一个项目，并将其在本地跑起来，整体跑通看看。 首先使用如下命令创建项目： 1hexo init &#123;name&#125; 这里的name就是项目名，我这里要创建59devops的博客，我就把项目取名为59devops了，用了纯小写，命令如下： 1hexo init 59devops 这样59devops文件夹下就会出现 Hexo 的初始化文件，包括 themes、scaffolds、source 等文件夹。 5.2 编译生成HTML代码首先进入新生成的文件夹里面，然后调用 Hexo 的 generate 命令，将 Hexo 编译生成 HTML 代码，命令如下： 1hexo generate 可以看到输出结果里面包含了 js、css、font 等内容，并发现他们都处在了项目根目录下的 public 文件夹下面了。 5.3 本地运行项目利用 Hexo 提供的 serve 命令把博客在本地运行起来，命令如下： 1hexo serve 项目成功运行在本地的4000端口上，浏览器访问http://localhost:4000： 6、部署项目将这个初始化的博客进行一下部署，放到 GitHub Pages 上面验证一下其可用性。成功之后我们可以再进行后续的修改，比如修改主题、修改页面配置等等。 Hexo 已经给我们提供一个命令，利用它我们可以直接将博客一键部署，不需要手动去配置服务器或进行其他的各项配置。 6.1 修改部署地址打开根目录下的 _config.yml 文件，找到 Deployment 这个地方，把刚才新建的 Repository 的地址贴过来，然后指定分支为 master 分支，最终修改为如下内容： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/59devops/59devops.github.io.git branch: master 6.2 安装Git部署插件需要额外安装一个支持 Git 的部署插件，名字叫做hexo-deployer-git，有了它我们才可以顺利将其部署到 GitHub 上面，如果不安装的话，在执行部署命令时会报如下错误： 1Deployer not found: git 安装hexo-deployer-git插件的命令如下： 1npm install hexo-deployer-git --save 6.3 部署项目安装成功后，执行部署命令： 1hexo deploy 如果出现类似上面的内容，就证明我们的博客已经成功部署到 GitHub Pages 上面了，这时候我们访问一下 GitHub Repository 同名的链接，比如我的59devops博客的 Repository 名称取的是59devops.github.io，那我就访问 http://59devops.github.io，这时候我们就可以看到跟本地一模一样的博客内容了。 查看一下GitHub上的内容： 这些内容实际上是博客文件夹下面的 public 文件夹下的所有内容，Hexo 把编译之后的静态页面内容上传到 GitHub 的 master 分支上面去了。 6.4 访问测试 6.5 上传博客源码到GitHub仓库那我博客的源码也想放到 GitHub 上面怎么办呢？其实很简单，新建一个其他的分支就好了，比如我这边就新建了一个 source 分支，代表博客源码的意思。 具体的添加过程就很简单了，参加如下命令： 123456git init # 初始化项目git checkout -b source # 创建并切换到source分支git add -A # 添加所有文件到暂存区git commit -m "init blog" # 提交并注释git remote add origin git@github.com:59devops/59devops.github.io.git # 添加到远程仓库git push origin source # 将代码提交到远程的source分支 在GitHub仓库中可以看到已经有两个分支： 7、配置站点信息完成如上内容之后，实际上我们只完成了博客搭建的一小步，因为我们仅仅是把初始化的页面部署成功了，博客里面还没有设置任何有效的信息。下面就让我们来进行一下博客的基本配置，另外换一个好看的主题，配置一些其他的内容，让博客真正变成属于我们自己的博客吧。 7.1 修改站点标题、关键字信息修改根目录下的 _config.yml 文件，找到 Site 区域，这里面可以配置站点标题 title、副标题 subtitle 等内容、关键字 keywords 等内容，比如我的就修改为如下内容： 12345678# Sitetitle: 59Devopssubtitle: 一个运维小菜鸡的个人博客网站。description: 记录学习、工作和生活中遇到的各种问题。keywords: &quot;运维, Python, Shell, ...&quot;author: StaryJielanguage: zh-CNtimezone: Asia/Shanghai hexo serve在本地运行并在浏览器中打开测试： 7.2 修改主题目前 Hexo 里面应用最多的主题基本就是 Next 主题了，个人感觉这个主题还是挺好看的，另外它支持的插件和功能也极为丰富，配置了这个主题，我们的博客可以支持更多的扩展功能，比如阅览进度条、中英文空格排版、图片懒加载等等。 7.2.1 下载主题目前 Next 主题已经更新到 7.x 版本了，我们可以直接到 Next 主题的 GitHub Repository 上把这个主题下载下来。 首先命令行进入到项目的根目录，执行如下命令即可： 1git clone https://github.com/theme-next/hexo-theme-next themes/next 执行完毕之后 Next 主题的源码就会出现在项目的 themes/next 文件夹下。 7.2.2 修改主题修改下博客所用的主题名称，修改项目根目录下的 _config.yml 文件，找到 theme 字段，修改为 next 即可，修改如下： 1theme: next 7.2.3 本地预览然后本地重新开启服务，访问刷新下页面，就可以看到 next 主题就切换成功了，预览效果如下： 7.3 配置主题现在我们已经成功切换到 next 主题上面了，接下来我们就对主题进行进一步地详细配置吧，比如修改样式、增加其他各项功能的支持。 Next 主题内部也提供了一个配置文件，名字同样叫做 _config.yml，只不过位置不一样，它在 themes/next 文件夹下，Next 主题里面所有的功能都可以通过这个配置文件来控制，下文所述的内容都是修改的 themes/next/_config.yml 文件。 7.3.1 样式Next 主题还提供了多种样式，风格都是类似黑白的搭配，但整个布局位置不太一样，通过修改配置文件的 scheme 字段即可，我选了 Pisces 样式，修改 _config.yml （注意是 themes/next/_config.yml 文件）如下： 1scheme: Pisces 另外还有几个可选项，比如： 1234# scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 重新在本地运行，浏览器查看就已经变成Pisces样式了： 7.4 faviconfavicon 就是站点标签栏的小图标，默认是用的 Hexo 的小图标，如果我们有站点 Logo 的图片的话，我们可以自己定制小图标。 7.4.1 获取图标但这并不意味着我们需要自己用 PS 自己来设计，已经有一个网站可以直接将图片转化为站点小图标，站点链接为：https://realfavicongenerator.net，到这里上传一张图，便可以直接打包下载各种尺寸和适配不同设备的小图标。 7.4.2 更换图标图标下载下来之后把它放在 themes/next/source/images 目录下面。 然后在配置文件里面找到 favicon 配置项，把一些相关路径配置进去即可，示例如下： 12345favicon: small: /images/favicon-16x16.png medium: /images/favicon-32x32.png apple_touch_icon: /images/apple-touch-icon.png safari_pinned_tab: /images/safari-pinned-tab.svg 配置完成之后刷新页面，整个页面的标签图标就被更新了。 7.5 avataravatar 这个就类似站点的头像，如果设置了这个，会在站点的作者信息旁边额外显示一个头像，比如我这边有一张 avatar.png 图片： 将其放置到 themes/next/source/images/avatar.png 路径，然后在主题 _config.yml 文件下编辑 avatar 的配置，修改为正确的路径即可。 12345678910# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.png # If true, the avatar would be dispalyed in circle. rounded: true # If true, the avatar would be rotated with the cursor. rotated: true 配置完成之后刷新页面，头像的图片就会显示出来。 7.6 rss博客一般是需要 RSS 订阅的，如果要开启 RSS 订阅，这里需要安装一个插件，叫做 hexo-generator-feed，安装完成之后，站点会自动生成 RSS Feed 文件，安装命令如下： 1npm install hexo-generator-feed --save 在项目根目录下运行这个命令，安装完成之后不需要其他的配置，以后每次编译生成站点的时候就会自动生成 RSS Feed 文件了。 7.7 code作为一个为程序员，虽然代码敲的不咋样，但是代码块的显示还是需要很讲究的，默认的代码块我个人不是特别喜欢，因此我把代码的颜色修改为黑色，并把复制按钮的样式修改为类似 Mac 的样式，修改 _config.yml 文件的 codeblock 区块如下： 12345678910111213codeblock: # Code Highlight theme # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic # See: https://github.com/chriskempson/tomorrow-theme # highlight_theme: normal highlight_theme: night bright # Add copy button on codeblock copy_button: enable: true # Show text copy result. show_result: true # Available values: default | flat | mac style: mac 修改样式前是这样的： 修改完之后是这样的： 7.8 top我们在浏览网页的时候，如果已经看完了想快速返回到网站的上端，一般都是有一个按钮来辅助的，这里也支持它的配置，修改 _config.yml 的 back2top 字段即可，我的设置如下： 123456back2top: enable: true # Back to top in sidebar. sidebar: false # Scroll percent label in b2t button. scrollpercent: true enable 默认为 true，即默认显示。sidebar 如果设置为 true，按钮会出现在侧栏下方，个人觉得并不是很好看，就取消了，scrollpercent 就是显示阅读百分比，个人觉得还不错，就将其设置为 true。 7.9 reading_processreading_process，阅读进度。大家可能注意到有些站点的最上侧会出现一个细细的进度条，代表页面加载进度和阅读进度，如果大家想设置的话也可以试试，我将其打开了，修改 _config.yml 如下： 1234567# Reading progress barreading_progress: enable: true # Available values: top | bottom position: top color: "#222" height: 2px 效果如下： 7.10 bookmark书签，可以根据阅读历史记录，在下次打开页面的时候快速帮助我们定位到上次的位置，大家可以根据喜好开启和关闭，我的配置如下： 1234567bookmark: enable: true # Customize the color of the bookmark. color: "#222" # If auto, save the reading progress when closing the page or clicking the bookmark-icon. # If manual, only save it by clicking the bookmark-icon. save: auto 7.11 github_banner在一些技术博客上，大家可能注意到在页面的右上角有个 GitHub 图标，点击之后可以跳转到其源码页面，可以为 GitHub Repository 引流，大家如果想显示的话可以自行选择打开，我的配置如下： 12345# `Follow me on GitHub` banner in the top-right corner.github_banner: enable: true permalink: https://github.com/59devops/59devops.github.io.git title: Follow 59devops on GitHub 效果如下： 7.12 gitalk由于 Hexo 的博客是静态博客，而且也没有连接数据库的功能，所以它的评论功能是不能自行集成的，但可以集成第三方的服务。 Next 主题里面提供了多种评论插件的集成，有 changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte 这些。 1.12.1 注册OAuth Application首先需要在 GitHub 上面注册一个 OAuth Application，链接为：https://github.com/settings/applications/new，注册完毕之后拿到 Client ID、Client Secret 就可以了。 1.12.2 修改配置首先需要在 _config.yml 文件的 comments 区域配置使用 gitalk： 1234567# Multiple Comment System Supportcomments: # Available values: tabs | buttons style: tabs # Choose a comment system to be displayed by default. # Available values: changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte active: gitalk 主要是 comments.active 字段选择对应的名称即可。 然后找打 gitalk 配置，添加它的各项配置： 123456789101112131415# Gitalk# Demo: https://gitalk.github.io# For more information: https://github.com/gitalk/gitalkgitalk: enable: true github_id: 59devops repo: 59devops.github.io client_id: cb34a61011c438548cec client_secret: 3d9c756a081ce2b91a6a286eb1a0a02a71ced6ca admin_user: 59devops distraction_free_mode: true # Facebook-like distraction free mode # Gitalk's display language depends on user's browser or system environment # If you want everyone visiting your site to see a uniform language, you can set a force language value # Available values: en | es-ES | fr | ru | zh-CN | zh-TW language: zh-CN 进入文章之后，效果如下： GitHub 授权登录之后就可以使用了，评论的内容会自动出现在 Issue 里面。 7.13 pangu如果你习惯在中文和英文之间留空格的话，pangu 就是来解决这个问题的，我们只需要在主题里面开启这个选项，在编译生成页面的时候，中英文之间就会自动添加空格，看起来更加美观。 具体的修改如下： 1pangu: true 7.14 math可能在一些情况下我们需要写一个公式，比如演示一个算法推导过程，MarkDown 是支持公式显示的，Hexo 的 Next 主题同样是支持的。 Next 主题提供了两个渲染引擎，分别是 mathjax 和 katex，后者相对前者来说渲染速度更快，而且不需要 JavaScript 的额外支持，但后者支持的功能现在还不如前者丰富，具体的对比可以看官方文档：https://theme-next.org/docs/third-party-services/math-equations。 这里选择了 mathjax，通过修改配置即可启用： 12345678910111213math: enable: true # Default (true) will load mathjax / katex script on demand. # That is it only render those page which has `mathjax: true` in Front-matter. # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE. per_page: true # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support. mathjax: enable: true # See: https://mhchem.github.io/MathJax-mhchem/ mhchem: true mathjax 的使用需要我们额外安装一个插件，叫做 hexo-renderer-kramed，另外也可以安装 hexo-renderer-pandoc，命令如下： 12npm un hexo-renderer-marked --savenpm i hexo-renderer-kramed --save 另外还有其他的插件支持，大家可以到官方文档查看。 7.15 pjax可能大家听说过 Ajax，没听说过 pjax，这个技术实际上就是利用 Ajax 技术实现了局部页面刷新，既可以实现 URL 的更换，有可以做到无刷新加载。 要开启这个功能需要先将 pjax 功能开启，然后安装对应的 pjax 依赖库，首先修改 _config.yml 修改如下： 1pjax: true 然后安装依赖库，切换到 next 主题下，然后安装依赖库： 12cd themes/nextgit clone https://github.com/theme-next/theme-next-pjax source/lib/pjax 这样 pjax 就开启了，页面就可以实现无刷新加载了。 7.16 其他配置参考官方文档：https://theme-next.org/docs/。 8、文章8.1 新建文章Hexo默认安装完就会有一篇文章，我们需要借助hexo命令添加新的文章： 1hexo new hello-hexo 创建的文章会出现在 source/_posts 文件夹下，是 MarkDown 格式。 8.2 文章标签和分类在文章开头通过如下格式添加必要信息： 1234567891011---title: 标题 # 自动创建，如 hello-worlddate: 日期 # 自动创建，如 2019-09-22 01:47:21tags: - 标签1- 标签2- 标签3categories:- 分类1- 分类2--- 开头下方撰写正文，MarkDown 格式书写即可。 这样在下次编译的时候就会自动识别标题、时间、类别等等，另外还有其他的一些参数设置，可以参考文档：https://hexo.io/zh-cn/docs/writing.html。 8.3 博客首页只显示文章标题和摘要默认情况下hexo博客(如本站)的首页显示的是完整的文章 – 而文章比较长的时候这无疑会带来诸多不便。只要加入一个&lt;!-- more --&gt;这样的占位符在文章正文里面即可： 123这就是一个简介&lt;!-- more --&gt;这里更多的内容 本地运行刷新后效果如下： 9、标签页现在我们的博客只有首页、文章页，如果我们想要增加标签页，可以自行添加，这里 Hexo 也给我们提供了这个功能，在根目录执行命令如下： 1hexo new page tags 执行这个命令之后会自动帮我们生成一个 source/tags/index.md 文件，内容就只有这样子的： 1234---title: tagsdate: 2019-09-27 11:42:49--- 我们可以自行添加一个 type 字段来指定页面的类型： 12type: tagscomments: false 然后再在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段如下： 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 本地运行刷新后，界面如下： 可以看到左侧导航也出现了标签，点击之后右侧会显示标签的列表。 10、分类页分类功能和标签类似，一个文章可以对应某个分类，如果要增加分类页面可以使用如下命令创建： 1hexo new page categories 然后同样地，会生成一个 source/categories/index.md 文件。 我们可以自行添加一个 type 字段来指定页面的类型： 12type: categoriescomments: false 然后再在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段如下： 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 刷新后页面如下： 11、搜索页很多情况下我们需要搜索全站的内容，所以一个搜索功能的支持也是很有必要的。 如果要添加搜索的支持，需要先安装一个插件，叫做 hexo-generator-searchdb，命令如下： 1npm install hexo-generator-searchdb --save 然后在项目的 _config.yml 里面添加搜索设置如下： 12345search: path: search.xml field: post format: html limit: 10000 然后在主题的 _config.yml 里面修改如下： 12345678910111213# Local Search# Dependencies: https://github.com/wzpan/hexo-generator-searchlocal_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 5 # Unescape html strings to the readable one. unescape: false # Preload the search data when the page loads. preload: false 这里用的是 Local Search，如果想启用其他是 Search Service 的话可以参考官方文档：https://theme-next.org/docs/third-party-services/search-services。 12、404页面另外还需要添加一个 404 页面，直接在根目录 source 文件夹新建一个 404.md 文件即可，内容可以仿照如下： 12345678910111213---title: 404 Not Founddate: 2019-09-27 12:21:37---&lt;center&gt;对不起，您所访问的页面不存在或者已删除。您可以&lt;a href="https://blog.59devops.com&gt;"&gt;点击此处&lt;/a&gt;返回首页。&lt;/center&gt;&lt;blockquote class="blockquote-center"&gt; 59Dveops&lt;/blockquote&gt; 这里面的一些相关信息和链接可以替换成自己的。 其实 Hexo 还有很多很多功能，可以直接参考官方文档：https://hexo.io/zh-cn/docs/ 查看更多的配置。 15、部署脚本最后我这边还增加了一个简易版的部署脚本，其实就是重新 gererate 下文件，然后重新部署。在根目录下新建一个 deploy.sh 的脚本文件，内容如下： 123hexo cleanhexo generatehexo deploy 这样我们在部署发布的时候只需要执行： 1sh deploy.sh 就可以完成博客的更新了，非常简单。 16、自定义域名将页面修改之后可以用上面的脚本重新部署下博客，其内容便会跟着更新。 另外我们也可以在 GitHub 的 Repository 里面设置域名，找到 Settings，拉到下面，可以看到有个 GitHub Pages 的配置项，如图所示： 下面有个 custom domain 的选项，输入你想自定义的域名地址，然后添加 CNAME 解析就好了。 另外下面还有一个 Enforce HTTPS 的选项，GitHub Pages 会在我们配置自定义域名之后自动帮我们配置 HTTPS 服务。刚配置完自定义域名的时候可能这个选项是不可用的，一段时间后等到其可以勾选了，直接勾选即可，这样整个博客就会变成 HTTPS 的协议的了。 另外有一个值得注意的地方，如果配置了自定义域名，在目前的情况下，每次部署的时候这个自定义域名的设置是会被自动清除的。所以为了避免这个情况，我们需要在项目目录下面新建一个 CNAME 文件，路径为 source/CNAME，内容就是自定义域名。 比如我就在 source 目录下新建了一个 CNAME 文件，内容为： 1blog.59devops.com 这样避免了每次部署的时候自定义域名被清除的情况了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
